native _{
    \#include <string.h>
    \#include <ctype.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

#define List(x) <[x,^]>
#define String List(_int)

var string_ce2c: \\String->_(char*) = func \\String->_(char*) {
    native _{static char STRING[256];}
    var aux: [_int,\\String]->() = func [_int,\\String]->() {
        var i: _int = arg.1
        if (/arg.2)?0 {
            native _{STRING[i] = '\0';}
            return
        } else {
            var c: _int = (/arg.2)!1.1
            native _{STRING[i] = c;}
            return aux [_(i+1), borrow \\(/arg.2)!1.2]
        }
    }
    call aux [_0, borrow arg]
    return _STRING
}

var string_c2ce: _(char*)->String = func _(char*)->String {
    var ret: String = <.0>
    var n: _int = call _strlen arg
    var i: _int = _0
    output std n
    loop {
        output std i
        if _(i == n) {
            break
        }
        set ret = new <.1 [_(arg[i]), move ret]>
        set i = _(i + 1)
    }
    return move ret
}

var keys: List(String) =
    new <.1 [string_c2ce _("var"), <.0>]>

var string_eq: [\\String,\\String]->_int = func [\\String,\\String]->_int {
    var nil1: _int = (/arg.1)?0
    var nil2: _int = (/arg.2)?0
    if nil1 {
        return nil2
    }
    if nil2 {
        return nil1
    }
    var c1: _int = (/arg.1)!1.1
    var c2: _int = (/arg.2)!1.1
    if _(c1 == c2) {
        return string_eq [borrow \\(/arg.1)!1.2, borrow \\(/arg.2)!1.2]
    }
    return _0
}

var finp: _(FILE*) = ?

var lx_blanks: ()->() = func ()->() {
    loop {
        var c: _int = call _fgetc finp
        if _(c=='\n' || c==' ') {
            -- space
        } else {
            native _(ungetc(c, finp);)
            return ()
        }
    }
}

var lx_token: ()-><(),_int> = func ()-><(),_int,String> {
    loop {
        var c: _int = call _fgetc finp
        if _(c == EOF) {
            return <.1>
        }
        if _(c=='{' || c==' ') {
            return <.2 c>
        }
        if _(isalpha(c)) {
            var str: String = <.0>
            loop {
                var c2: _int = call _fgetc finp
                set str = new <.1 [c2,move str]>
                if _(!isalpha(c2)) {
                    native _(ungetc(c, finp);)
                    break
                }
            }
            return <.3 move str>
        }
    }
}

var t_pre: ()->() = func ()->() {
    var s1: String   = string_c2ce _("oi")
    var s2: _(char*) = string_ce2c borrow \\s1
    call _assert _(!strcmp(s2,"oi"))

    var s3: String = new <.1 [_('o'), new <.1 [_('i'), <.0>]>]>
    var ok: _int = call string_eq [borrow \\s1, borrow \\s3]
    call _assert ok
}

var t_lexer: ()->() = func ()->() {
    -- CHAR / BLANK / CHAR
    {
        set finp = _{stropen("r", 0, "- \\n -")}
        var c1: _int = call _fgetc finp
        native _(assert(c1 == '-');)
        native _(ungetc(c1,finp);)
        var c2: _int = call _fgetc finp
        native _(assert(c2 == '-');)
        call lx_blanks ()
        var c3: _int = call _fgetc finp
        native _(assert(c3 == '-');)
        call _fclose finp
    }
    -- TOKENS / BLANK
    {
        set finp = _{stropen("r", 0, "{\\nvar foo\\n}")}
        var c1: _int = call _fgetc finp
        native _(assert(c1 == '-');)
        native _(ungetc(c1,finp);)
        var c2: _int = call _fgetc finp
        native _(assert(c2 == '-');)
        call lx_blanks ()
        var c3: _int = call _fgetc finp
        native _(assert(c3 == '-');)
        call _fclose finp
    }
}

call t_lexer  ()
output std ()
