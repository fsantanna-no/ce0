#define COMMA ,

native _{
    \#include <string.h>
    \#include <ctype.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

#define List(x) <[x,^]>
#define String List(_int)

var string_len: \\String->_int = func \\String->_int {
    if (/arg)?0 {
        return _0
    } else {
        var n: _int = call string_len borrow \\(/arg)!1.2
        return _(1 + n)
    }
}

var string_ce2c: \\String->_(char*) = func \\String->_(char*) {
    native _{static char STRING[256];}
    var n: _int = string_len (borrow arg)
    var aux: [_int,\\String]->() = func [_int,\\String]->() {
        var i: _int = arg.1
        if (/arg.2)?1 {
            var c: _int = (/arg.2)!1.1
            native _{STRING[n-i] = c;}
            return aux [_(i+1), borrow \\(/arg.2)!1.2]
        }
    }
    call aux [_1, borrow arg]
    native _{STRING[n] = '\\0';}
    return _STRING
}

var string_c2ce: _(char*)->String = func _(char*)->String {
    var ret: String = <.0>
    var n: _int = call _strlen arg
    var i: _int = _0
    loop {
        if _(i == n) {
            break
        }
        set ret = new <.1 [_(arg[i]), move ret]>
        set i = _(i + 1)
    }
    return move ret
}

#define KEY <(),()>
#define KEYS List([KEY COMMA String])
var keys: KEYS =
    new <.1 [[<.1>,string_c2ce _("set")],
    new <.1 [[<.2>,string_c2ce _("var")], <.0>]>]>

var string_eq: [\\String,\\String]->_int = func [\\String,\\String]->_int {
    var nil1: _int = (/arg.1)?0
    var nil2: _int = (/arg.2)?0
    if nil1 {
        return nil2
    }
    if nil2 {
        return nil1
    }
    var c1: _int = (/arg.1)!1.1
    var c2: _int = (/arg.2)!1.1
    if _(c1 == c2) {
        return string_eq [borrow \\(/arg.1)!1.2, borrow \\(/arg.2)!1.2]
    }
    return _0
}

var finp: _(FILE*) = ?

var lx_blanks: ()->() = func ()->() {
    loop {
        var c: _int = call _fgetc finp
        if _(c=='\\n' || c==' ') {
            -- space
        } else {
            native _(ungetc(c, finp);)
            return ()
        }
    }
}

var keys_find: \\String-><(),KEY> = func \\String-><(),KEY> {
    var str: \\String = borrow arg
    var aux: \\KEYS-><(),KEY> = func \\KEYS-><(),KEY> {
        if (/arg)?0 {
            return <.1>
        }
        if string_eq [borrow str, borrow \\(/arg)!1.1.2] {
            return <.2 (/arg)!1.1.1>
        }
        return aux borrow \\(/arg)!1.2
    }
    return aux borrow \\keys
}

-- EOF,sym,key,var
#define LX_TOKEN <(),_int,KEY,String>
var lx_token: ()->LX_TOKEN = func ()->LX_TOKEN {
    loop {
        var c: _int = call _fgetc finp
        if _(c == EOF) {
            return <.1>
        }
        if _(c=='{' || c=='}') {
            return <.2 c>
        }
        if _(isalpha(c)) {
            var str: String = <.0>
            loop {
                set str = new <.1 [c,move str]>
                set c = call _fgetc finp
                if _(!isalpha(c)) {
                    native _(ungetc(c, finp);)
                    break
                }
            }
            var key: <(),KEY> = call keys_find borrow \\str
            if key?2 {
                return <.3 key!2>
            } else {
                return <.4 move str>
            }
        }
    }
}

var lexer: ()->LX_TOKEN = func ()->LX_TOKEN {
    call lx_blanks
    var ret: LX_TOKEN = call lx_token
    call lx_blanks
    return move ret
}

var t_pre: ()->() = func ()->() {
    var s1: String   = string_c2ce _("oi")
    var s2: _(char*) = string_ce2c borrow \\s1
    call _assert _(!strcmp(s2,"oi"))

    var s3: String = new <.1 [_('i'), new <.1 [_('o'), <.0>]>]>
    var ok: _int = call string_eq [borrow \\s1, borrow \\s3]
    call _assert ok
}

var t_lexer: ()->() = func ()->() {
    -- CHAR / BLANK / CHAR
    {
        set finp = _{stropen("r", 0, "- \\n -")}
        var c1: _int = call _fgetc finp
        native _(assert(c1 == '-');)
        native _(ungetc(c1,finp);)
        var c2: _int = call _fgetc finp
        native _(assert(c2 == '-');)
        call lx_blanks ()
        var c3: _int = call _fgetc finp
        native _(assert(c3 == '-');)
        call _fclose finp
    }
    -- TOKENS / BLANK
    {
        set finp = _{stropen("r", 0, "{\\nvar foo set\\n}")}

        var tk1: LX_TOKEN = call lx_token ()
        call lx_blanks ()
        call _assert (tk1?2)
        var c1: _int = tk1!2
        call _assert _(c1 == '{')

        var tk2: LX_TOKEN = call lx_token ()
        call lx_blanks ()
        call _assert (tk2?3)
        call _assert (tk2!3?2)

        var tk3: LX_TOKEN = call lx_token ()
        call lx_blanks ()
        call _assert (tk3?4)
        var s31: \\<[_int,^]> = borrow \\tk3!4
        var s32: String = string_c2ce _("foo")
        call _assert string_eq [borrow s31, borrow \\s32]

        var tk4: LX_TOKEN = call lx_token ()
        call lx_blanks ()
        call _assert (tk4?3)
        call _assert (tk4!3?1)

        call _fclose finp
    }
    -- LEXER
    {
        set finp = _{stropen("r", 0, "{\\nvar foo set\\n}")}

        var tk1: LX_TOKEN = call lexer () ; call _assert (tk1?2)
        var tk2: LX_TOKEN = call lexer () ; call _assert (tk2?3)
        var tk3: LX_TOKEN = call lexer () ; call _assert (tk3?4)
        var tk4: LX_TOKEN = call lexer () ; call _assert (tk4?3)
        var tk5: LX_TOKEN = call lexer () ; call _assert (tk5?2)
        var tk6: LX_TOKEN = call lexer () ; call _assert (tk6?1)

        call _fclose finp
    }
}

var t_parser: ()->() = func ()->() {
}

call t_pre
call t_lexer
call t_parser
output std ()
