native _{
    \#include <string.h>
    \#include <ctype.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

#define Maybe(x) <(),x>
#define List(x) <?[x,^]>
#define String List(_int)

#define Token <(),_int,KEY,String,(),_int>
    -- EOF,sym,key,var,unit,num

#define Type <(),List(^^),List(^^)>
    -- Unit, Tuple, Union

#define Stmt ()

#define Expr <(), Token, List(^^), [_int,^], [^,_int], [^,_int], [^,^], [Type,Stmt]>
    -- Unit, Var, TCons, UCons, TDisc, UDisc, Call, Func

var@ string_len: \\String->_int = func \\String->_int {
    if (/arg)?0 {
        return _0
    } else {
        var n: _int = call string_len borrow \\(/arg)!1.2
        return _(1 + n)
    }
}

var@ string_ce2c: \\String->_(char*) = func \\String->_(char*) {
    native _{static char STRING[256];}
    var n: _int = string_len borrow arg
    var@ aux: [_int,\\String]->() = func [_int,\\String]->() {
        var i: _int = arg.1
        if (/arg.2)?1 {
            var c: _int = (/arg.2)!1.1
            native _{STRING[n-i] = c;}
            return aux [_(i+1), borrow \\(/arg.2)!1.2]
        }
    }
    call aux [_1, borrow arg]
    native _{STRING[n] = '\\0';}
    return _STRING
}

var@ string_c2ce: _(char*)->String = func _(char*)->String {
    var ret: String = <.0>
    var n: _int = call _strlen arg
    var i: _int = _0
    loop {
        if _(i == n) {
            break
        }
        set ret = new <.1 [_(arg[i]), consume ret]>
        set i = _(i + 1)
    }
    return consume ret
}

#define KEY <(),()>
#define KEYS List([KEY \, String])
var@ keys: KEYS =
    new <.1 [[<.1>,string_c2ce _("set")],
    new <.1 [[<.2>,string_c2ce _("var")], <.0>]>]>

var@ string_eq: [\\String,\\String]->_int = func [\\String,\\String]->_int {
    var nil1: _int = (/arg.1)?0
    var nil2: _int = (/arg.2)?0
    if nil1 {
        return nil2
    }
    if nil2 {
        return nil1
    }
    var c1: _int = (/arg.1)!1.1
    var c2: _int = (/arg.2)!1.1
    if _(c1 == c2) {
        return string_eq [borrow \\(/arg.1)!1.2, borrow \\(/arg.2)!1.2]
    }
    return _0
}

var@ finp: _(FILE*) = ?
var@ tk0: Token = <.1>
var@ tk1: Token = <.1>

var@ lx_blanks: ()->() = func ()->() {
    loop {
        var c: _int = call _fgetc finp
        if _(c=='\\n' || c==' ') {
            -- space
        } else {
            native _(ungetc(c, finp);)
            return ()
        }
    }
}

var@ keys_find: \\String->Maybe(KEY) = func \\String->Maybe(KEY) {
    var@ aux: [\\String,\\KEYS]->Maybe(KEY) = func [\\String,\\KEYS]->Maybe(KEY) {
        if (/arg.2)?0 {
            return <.1>
        }
        if string_eq [borrow arg.1, borrow \\(/arg.2)!1.1.2] {
            return <.2 (/arg.2)!1.1.1>
        }
        return aux [borrow arg.1, borrow \\(/arg.2)!1.2]
    }
    return aux [borrow arg, borrow \\keys]
}

var@ lx_token: ()->Token = func ()->Token {
    loop {
        var c: _int = call _fgetc finp
        if _(c == EOF) {
            return <.1>
        }
        if _(c=='[' || c==']' || c=='<' || c=='>' || c=='{' || c=='}' || c==',' || c=='.') {
            return <.2 c>
        }
        if _{c=='('} {
            set c = call _fgetc finp
            call _assert _{c == ')'}
            return <.5>
        }
        if _(isalpha(c)) {
            var str: String = <.0>
            loop {
                set str = new <.1 [c,consume str]>
                set c = call _fgetc finp
                if _(!isalpha(c)) {
                    native _(ungetc(c, finp);)
                    break
                }
            }
            var key: Maybe(KEY) = call keys_find borrow \\str
            if key?2 {
                return <.3 key!2>
            } else {
                return <.4 consume str>
            }
        }
        if _(isdigit(c)) {
            var str: String = <.0>
            loop {
                set str = new <.1 [c,consume str]>
                set c = call _fgetc finp
                if _(!isdigit(c)) {
                    native _(ungetc(c, finp);)
                    break
                }
            }
            var cstr: _(char*) = string_ce2c borrow \\str
            return <.6 _atoi cstr>
        }

    }
}

var@ lexer: ()->() = func ()->() {
    call lx_blanks
    set tk0 = copy tk1
    set tk1 = call lx_token
    call lx_blanks
}

var@ tk_check: [_int,Maybe(_int)]->_int = func [_int,Maybe(_int)]->_int {
    var enu: _int = arg.1
    if _(enu == 1) {
        return tk1?1
    }
    if _(enu == 2) {
        if tk1?2 {
            var c1: _int = tk1!2
            var c2: _int = arg.2!2
            return _(c1 == c2)
        }
        return _0
    }
    if _(enu == 3) {
        return tk1?3
    }
    if _(enu == 4) {
        return tk1?4
    }
    if _(enu == 5) {
        return tk1?5
    }
    if _(enu == 6) {
        return tk1?6
    }
    call _assert _0
}

var@ tk_accept: [_int,Maybe(_int)]->_int = func [_int,Maybe(_int)]->_int {
    var ok: _int = tk_check arg
    if ok {
        call lexer
    }
    return ok
}

-- EOF,sym,key,var,unit
var@ parser_type: ()->Maybe(Type) = func ()->Maybe(Type) {
    if tk_accept [_5,<.1>] {
        return <.2 new <.1>>        -- Unit
    }
    var ok: _int = call tk_accept [_2, <.2 _('[')>]
    if _(!ok) {
        set ok = call tk_accept [_2, <.2 _('<')>]
    }
    if ok {
        var open: _int = tk0!2
        var tp: Maybe(Type) = call parser_type ()
        var tps: List(Type) = new <.1 [consume tp!2, <.0>]>
        loop {
            set ok = tk_accept [_2, <.2 _(',')>]
            if _(!ok) {
                break
            }
            set tp = call parser_type ()
            set tps = new <.1 [consume tp!2, consume tps]>
        }
        if _(open == '[') {
            call _assert tk_accept [_2, <.2 _(']')>]
            return <.2 new <.2 consume tps>>
        } else {
            call _assert tk_accept [_2, <.2 _('>')>]
            return <.2 new <.3 consume tps>>
        }
    }

    return <.1>
}

-- EOF,sym,key,var,unit
-- Unit, Var, TCons, UCons, TDisc, UDisc, Call, Func
var@ parser_expr: ()->Maybe(Expr) = func ()->Maybe(Expr) {
    if tk_accept [_5,<.1>] {    -- Unit
        return <.2 new <.1>>
    }
    if tk_accept [_4,<.1>] {    -- Var
        return <.2 new <.2 copy tk0>>
    }
    if tk_accept [_2, <.2 _('[')>] {
        var e: Maybe(Expr) = call parser_expr ()
        var es: List(Expr) = new <.1 [consume e!2, <.0>]>
        loop {
            if tk_accept [_2, <.2 _(',')>] {
                set e = call parser_expr ()
                set es = new <.1 [consume e!2, consume es]>
            } else {
                break
            }
        }
        call _assert tk_accept [_2, <.2 _(']')>]
        return <.2 new <.3 consume es>>
    }
    if tk_accept [_2, <.2 _('<')>] {
        call _assert tk_accept [_2, <.2 _('.')>]
        call _assert tk_accept [_6, <.1>]
        var n: _int = tk0!6
        var e: Maybe(Expr) = call parser_expr ()
        if e?2 {
            -- ok
        } else {
            set e = <.2 new <.1>>
        }
        call _assert tk_accept [_2, <.2 _('>')>]
        return <.2 new <.4 [n, consume e!2]>>
    }
    return <.1>
}

var t_pre: ()->() = func ()->() {
    var s1: String   = string_c2ce _("oi")
    var s2: _(char*) = string_ce2c borrow \\s1
    call _assert _(!strcmp(s2,"oi"))

    var s3: String = new <.1 [_('i'), new <.1 [_('o'), <.0>]>]>
    var ok: _int = call string_eq [borrow \\s1, borrow \\s3]
    call _assert ok
}

var t_lexer: ()->() = func ()->() {
    -- CHAR / BLANK / CHAR
    {
        set finp = _{stropen("r", 0, "- \\n -")}
        var c1: _int = call _fgetc finp
        native _(assert(c1 == '-');)
        native _(ungetc(c1,finp);)
        var c2: _int = call _fgetc finp
        native _(assert(c2 == '-');)
        call lx_blanks ()
        var c3: _int = call _fgetc finp
        native _(assert(c3 == '-');)
        call _fclose finp
    }
    -- TOKENS / BLANK
    {
        set finp = _{stropen("r", 0, "{\\nvar foo set\\n}")}

        var k1: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k1?2)
        var c1: _int = k1!2
        call _assert _(c1 == '{')

        var k2: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k2?3)
        call _assert (k2!3?2)

        var k3: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k3?4)
        var s31: \\String = borrow \\k3!4
        var s32: String = string_c2ce _("foo")
        call _assert string_eq [borrow s31, borrow \\s32]

        var k4: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k4?3)
        call _assert (k4!3?1)

        call _fclose finp
    }
    -- LEXER
    {
        set finp = _{stropen("r", 0, "{\\nvar () \\n foo set\\n}")}

        -- EOF,sym,key,var,unit
        call lexer () ; call _assert (tk1?2)
        call lexer () ; call _assert (tk1?3)
        call lexer () ; call _assert (tk1?5)
        call lexer () ; call _assert (tk1?4)
        call lexer () ; call _assert (tk1?3)
        call lexer () ; call _assert (tk1?2)
        call lexer () ; call _assert (tk1?1)

        call _fclose finp
    }
}

var t_parser: ()->() = func ()->() {
    var t_parser_type: ()->() = func ()->() {
        {
            set finp = _{stropen("r", 0, "() x [(),()] <()>")}
            call lexer
            var tp1: Maybe(Type) = call parser_type
            call _assert tp1!2?1
            var tp2: Maybe(Type) = call parser_type
            call _assert tp2?1
            call lexer
            var tp3: Maybe(Type) = call parser_type
            call _assert tp3!2?2
            var tp4: Maybe(Type) = call parser_type
            call _assert tp4!2?3
            call _fclose finp
        }
    }

    var t_parser_expr: ()->() = func ()->() {
        {
            set finp = _{stropen("r", 0, "() x [(),()] <.0> <.1 x>")}
            call lexer
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?1
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?2
                call _assert e!2!2?4
                var s: String = string_c2ce _("x")
                call _assert string_eq [borrow \\e!2!2!4, borrow \\s]
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?3
                call _assert e!2!3?1
                call _assert e!2!3!1.2?1
                call _assert e!2!3!1.2!1.2?0
                call _assert e!2!3!1.2!1.1?1
                -- e.some.tup.pair.2.pair.1
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?4
                var n: _int = e!2!4.1
                call _assert _(n == 0)
                call _assert e!2!4.2?1
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?4
                var n: _int = e!2!4.1
                call _assert _(n == 1)
                call _assert e!2!4.2?2
            }
            call _fclose finp
        }
    }

    call t_parser_type
    call t_parser_expr
}

call t_pre
call t_lexer
call t_parser

output std ()
