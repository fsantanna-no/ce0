#define COMMA ,

native _{
    \#include <string.h>
    \#include <ctype.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

#define Maybe(x) <(),x>
#define List(x) <[x,^]>
#define String List(_int)

#define Token <(),_int,KEY,String,()>
    -- EOF,sym,key,var,unit

#define Type <(),List(^^),List(^^)>
    -- Unit, Tuple, Union

var string_len: \\String->_int = func \\String->_int {
    if (/arg)?0 {
        return _0
    } else {
        var n: _int = call string_len borrow \\(/arg)!1.2
        return _(1 + n)
    }
}

var string_ce2c: \\String->_(char*) = func \\String->_(char*) {
    native _{static char STRING[256];}
    var n: _int = string_len (borrow arg)
    var aux: [_int,\\String]->() = func [_int,\\String]->() {
        var i: _int = arg.1
        if (/arg.2)?1 {
            var c: _int = (/arg.2)!1.1
            native _{STRING[n-i] = c;}
            return aux [_(i+1), borrow \\(/arg.2)!1.2]
        }
    }
    call aux [_1, borrow arg]
    native _{STRING[n] = '\\0';}
    return _STRING
}

var string_c2ce: _(char*)->String = func _(char*)->String {
    var ret: String = <.0>
    var n: _int = call _strlen arg
    var i: _int = _0
    loop {
        if _(i == n) {
            break
        }
        set ret = new <.1 [_(arg[i]), move ret]>
        set i = _(i + 1)
    }
    return move ret
}

#define KEY <(),()>
#define KEYS List([KEY COMMA String])
var keys: KEYS =
    new <.1 [[<.1>,string_c2ce _("set")],
    new <.1 [[<.2>,string_c2ce _("var")], <.0>]>]>

var string_eq: [\\String,\\String]->_int = func [\\String,\\String]->_int {
    var nil1: _int = (/arg.1)?0
    var nil2: _int = (/arg.2)?0
    if nil1 {
        return nil2
    }
    if nil2 {
        return nil1
    }
    var c1: _int = (/arg.1)!1.1
    var c2: _int = (/arg.2)!1.1
    if _(c1 == c2) {
        return string_eq [borrow \\(/arg.1)!1.2, borrow \\(/arg.2)!1.2]
    }
    return _0
}

var finp: _(FILE*) = ?
var tk: Token = <.1>

var lx_blanks: ()->() = func ()->() {
    loop {
        var c: _int = call _fgetc finp
        if _(c=='\\n' || c==' ') {
            -- space
        } else {
            native _(ungetc(c, finp);)
            return ()
        }
    }
}

var keys_find: \\String->Maybe(KEY) = func \\String->Maybe(KEY) {
    var str: \\String = borrow arg
    var aux: \\KEYS->Maybe(KEY) = func \\KEYS->Maybe(KEY) {
        if (/arg)?0 {
            return <.1>
        }
        if string_eq [borrow str, borrow \\(/arg)!1.1.2] {
            return <.2 (/arg)!1.1.1>
        }
        return aux borrow \\(/arg)!1.2
    }
    return aux borrow \\keys
}

var lx_token: ()->Token = func ()->Token {
    loop {
        var c: _int = call _fgetc finp
        if _(c == EOF) {
            return <.1>
        }
        if _(c=='{' || c=='}') {
            return <.2 c>
        }
        if _{c=='('} {
            set c = call _fgetc finp
            call _assert _{c == ')'}
            return <.5>
        }
        if _(isalpha(c)) {
            var str: String = <.0>
            loop {
                set str = new <.1 [c,move str]>
                set c = call _fgetc finp
                if _(!isalpha(c)) {
                    native _(ungetc(c, finp);)
                    break
                }
            }
            var key: Maybe(KEY) = call keys_find borrow \\str
            if key?2 {
                return <.3 key!2>
            } else {
                return <.4 move str>
            }
        }
    }
}

var lexer: ()->() = func ()->() {
    call lx_blanks
    set tk = call lx_token
    call lx_blanks
}

var tk_check: [_int,Maybe(_int)]->_int = func [_int,Maybe(_int)]->_int {
    var enu: _int = arg.1
    if _(enu == 1) {
        return tk?1
    }
    if _(enu == 2) {
        if tk?2 {
            var c1: _int = tk!2
            var c2: _int = arg.2!2
            return _(c1 == c2)
        }
        return _0
    }
    if _(enu == 3) {
        return tk?3
    }
    if _(enu == 4) {
        return tk?4
    }
    if _(enu == 5) {
        return tk?5
    }
    call _assert _0
}

var tk_accept: [_int,Maybe(_int)]->_int = func [_int,Maybe(_int)]->_int {
    var ok: _int = tk_check arg
    if ok {
        call lexer
    }
    return ok
}

-- EOF,sym,key,var,unit
var parser_type: ()->Maybe(Type) = func ()->Maybe(Type) {
    if tk_accept [_5,<.1>] {
        return <.2 new <.1>>
    }
    var ok: _int = call tk_accept [_2, _('[')]
    if _(!ok) {
        set ok = call tk_accept [_2, _('<')]
    }
    if ok {
        var open: _int = tk!2
        var tp: Maybe(Type) = move parser_type ()
        var tps: List(Type) = new <.1 [move tp!2, <.0>]>
        loop {
            set ok = tk_accept [_2, _(',')]
            if _(!ok) {
                break
            }
            set tp = move parser_type ()
            set tps = new <.1 [move tp!2, move tps]>
        }
        if _(open == '[') {
            call _assert tk_accept [_2, _(']')]
            return <.2 <.2 move tps>>
        } else {
            call _assert tk_accept [_2, _('>')]
            return <.2 <.3 move tps>>
        }
    }

    return <.1>
}

var t_pre: ()->() = func ()->() {
    var s1: String   = string_c2ce _("oi")
    var s2: _(char*) = string_ce2c borrow \\s1
    call _assert _(!strcmp(s2,"oi"))

    var s3: String = new <.1 [_('i'), new <.1 [_('o'), <.0>]>]>
    var ok: _int = call string_eq [borrow \\s1, borrow \\s3]
    call _assert ok
}

var t_lexer: ()->() = func ()->() {
    -- CHAR / BLANK / CHAR
    {
        set finp = _{stropen("r", 0, "- \\n -")}
        var c1: _int = call _fgetc finp
        native _(assert(c1 == '-');)
        native _(ungetc(c1,finp);)
        var c2: _int = call _fgetc finp
        native _(assert(c2 == '-');)
        call lx_blanks ()
        var c3: _int = call _fgetc finp
        native _(assert(c3 == '-');)
        call _fclose finp
    }
    -- TOKENS / BLANK
    {
        set finp = _{stropen("r", 0, "{\\nvar foo set\\n}")}

        var k1: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k1?2)
        var c1: _int = k1!2
        call _assert _(c1 == '{')

        var k2: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k2?3)
        call _assert (k2!3?2)

        var k3: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k3?4)
        var s31: \\<[_int,^]> = borrow \\k3!4
        var s32: String = string_c2ce _("foo")
        call _assert string_eq [borrow s31, borrow \\s32]

        var k4: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k4?3)
        call _assert (k4!3?1)

        call _fclose finp
    }
    -- LEXER
    {
        set finp = _{stropen("r", 0, "{\\nvar () \\n foo set\\n}")}

        -- EOF,sym,key,var,unit
        call lexer () ; call _assert (tk?2)
        call lexer () ; call _assert (tk?3)
        call lexer () ; call _assert (tk?5)
        call lexer () ; call _assert (tk?4)
        call lexer () ; call _assert (tk?3)
        call lexer () ; call _assert (tk?2)
        call lexer () ; call _assert (tk?1)

        call _fclose finp
    }
}

var t_parser_type: ()->Maybe(Type) = func ()->Maybe(Type) {
    {
        set finp = _{stropen("r", 0, "() x")}
        call lexer
        var tp1: Maybe(Type) = call parser_type
        call _assert tp1!2?1
        var tp2: Maybe(Type) = call parser_type
        call _assert tp2?1
        call _fclose finp
    }
}

var t_parser: ()->() = func ()->() {
    call t_parser_type
}

call t_pre
call t_lexer
call t_parser

output std ()
