native _{
    \#include <string.h>
    \#include <ctype.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

#include "types.ce"
#include "string.ce"
#include "globals.ce"
#include "lexer.ce"
#include "parser.ce"
#include "visit.ce"

var t_pre: ()->() = func ()->() {
    var s1: String   = string_c2ce _("oi")
    var s2: _(char*) = string_ce2c borrow \\s1
    call _assert _(!strcmp(s2,"oi"))

    var s3: String = new <.1 [_('i'), new <.1 [_('o'), <.0>]>]>
    var ok: _int = call string_eq [borrow \\s1, borrow \\s3]
    call _assert ok
}

var t_lexer: ()->() = func ()->() {
    -- CHAR / BLANK / CHAR
    {
        set finp = _{stropen("r", 0, "- \\n -")}
        var c1: _int = call _fgetc finp
        native _(assert(c1 == '-');)
        native _(ungetc(c1,finp);)
        var c2: _int = call _fgetc finp
        native _(assert(c2 == '-');)
        call lx_blanks ()
        var c3: _int = call _fgetc finp
        native _(assert(c3 == '-');)
        call _fclose finp
    }
    -- TOKENS / BLANK
    {
        set finp = _{stropen("r", 0, "{\\nvar foo set\\n}")}

        var k1: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k1?2)
        var c1: _int = k1!2
        call _assert _(c1 == '{')

        var k2: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k2?3)
        call _assert (k2!3?3)

        var k3: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k3?4)
        var s31: \\String = borrow \\k3!4
        var s32: String = string_c2ce _("foo")
        call _assert string_eq [borrow s31, borrow \\s32]

        var k4: Token = call lx_token ()
        call lx_blanks ()
        call _assert (k4?3)
        call _assert (k4!3?2)

        call _fclose finp
    }
    -- LEXER
    {
        set finp = _{stropen("r", 0, "{\\nvar () \\n foo set\\n}")}

        -- EOF,sym,key,var,unit
        call lexer () ; call _assert (tk1?2)
        call lexer () ; call _assert (tk1?3)
        call lexer () ; call _assert (tk1?5)
        call lexer () ; call _assert (tk1?4)
        call lexer () ; call _assert (tk1?3)
        call lexer () ; call _assert (tk1?2)
        call lexer () ; call _assert (tk1?1)

        call _fclose finp
    }
}

var t_parser: ()->() = func ()->() {
    var t_parser_type: ()->() = func ()->() {
        {
            set finp = _{stropen("r", 0, "() x [(),()] <()>")}
            call lexer
            var tp1: Maybe(Type) = call parser_type
            call _assert tp1!2?1
            var tp2: Maybe(Type) = call parser_type
            call _assert tp2?1
            call lexer
            var tp3: Maybe(Type) = call parser_type
            call _assert tp3!2?2
            var tp4: Maybe(Type) = call parser_type
            call _assert tp4!2?3
            call _fclose finp
        }
    }

    var t_parser_expr: ()->() = func ()->() {
        {
            set finp = _{stropen("r", 0, "() x [(),()] <.0> <.1 x>")}
            call lexer
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?1
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?2
                var s: String = string_c2ce _("x")
                call _assert string_eq [borrow \\e!2!2, borrow \\s]
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?3
                call _assert e!2!3?1
                call _assert e!2!3!1.2?1
                call _assert e!2!3!1.2!1.2?0
                call _assert e!2!3!1.2!1.1?1
                -- e.some.tup.pair.2.pair.1
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?4
                var n: _int = e!2!4.1
                call _assert _(n == 0)
                call _assert e!2!4.2?1
            }
            {
                var e: Maybe(Expr) = call parser_expr
                call _assert e!2?4
                var n: _int = e!2!4.1
                call _assert _(n == 1)
                call _assert e!2!4.2?2
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "x.1")}
            call lexer
            {
                var e: Maybe(Expr) = call parser_exprs
                call _assert e!2?5
                var n: _int = e!2!5.2
                call _assert _(n == 1)
                var s1: String = string_c2ce _("x")
                var s2: \\String = borrow \\e!2!5.1!2
                call _assert string_eq [borrow \\s1, borrow s2]
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "()!0")}
            call lexer
            {
                var e: Maybe(Expr) = call parser_exprs
                call _assert e!2?6
                var n: _int = e!2!6.2
                call _assert _(n == 0)
                call _assert e!2!6.1?1
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "<.0>!10?20")}
            call lexer
            {
                var e: Maybe(Expr) = call parser_exprs
                call _assert e!2?7
                var n1: _int = e!2!7.2
                call _assert _(n1 == 20)
                call _assert e!2!7.1?6
                call _assert e!2!7.1!6.1?4
                var n2: _int = e!2!7.1!6.2
                call _assert _(n2 == 10)
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "() ()")}
            call lexer
            {
                var e: Maybe(Expr) = call parser_exprs
                call _assert e!2?8
                call _assert e!2!8.1?1
                call _assert e!2!8.2?1
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "func () { pass }")}
            call lexer
            {
                var e: Maybe(Expr) = call parser_exprs
                call _assert e!2?9
                call _assert e!2!9.1?1
                call _assert e!2!9.2?3
                call _assert e!2!9.2!3?1
                call _assert e!2!9.2!3!1.1?1
                call _assert e!2!9.2!3!1.2?0
            }
            call _fclose finp
        }
    }

    var t_parser_stmt: ()->() = func ()->() {
        {
            set finp = _{stropen("r", 0, "pass")}
            call lexer
            {
                var s: Maybe(Stmt) = call parser_stmt
                call _assert s!2?1
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "var x: () = ()")}
            call lexer
            {
                var s: Maybe(Stmt) = call parser_stmt
                call _assert s!2?2
                call _assert s!2!2.1?1
                call _assert s!2!2.2?1
                call _assert s!2!2.3?1
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "pass ; pass")}
            call lexer
            {
                var s: Stmt = call parser_stmts
                call _assert s?3
                call _assert s!3?1
                call _assert s!3!1.1?1
                call _assert s!3!1.2?1
                call _assert s!3!1.2!1.1?1
                call _assert s!3!1.2!1.2?0
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "var x: () = y")}
            call lexer
            {
                var s: Maybe(Stmt) = call parser_stmt
                call _assert s!2?2
                call _assert s!2!2.1?1
                call _assert s!2!2.2?1
                call _assert s!2!2.3?2
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "")}
            call lexer
            {
                var s: Stmt = call parser_stmts
                call _assert s?3
                call _assert s!3?0
            }
            call _fclose finp
        }
        {
            set finp = _{stropen("r", 0, "var f: () = func () { pass }")}
            call lexer
            {
                var s: Stmt = call parser_stmts
                call _assert s?3        -- lista
                call _assert s!3?1      -- cons
                call _assert s!3!1.1?2  -- var
                call _assert s!3!1.2?0  -- nil
                var e: Expr = consume s!3!1.1!2.3
                call _assert e?9
                call _assert e!9.1?1
                call _assert e!9.2?3
                call _assert e!9.2!3?1
                call _assert e!9.2!3!1.1?1
                call _assert e!9.2!3!1.2?0
            }
            call _fclose finp
        }
    }

    call t_parser_type
    call t_parser_expr
    call t_parser_stmt
}

var t_visit: ()->() = func ()->() {
    var@ x: _int = _0
    var fs: FS = func FS {
        set x = _(x+1)
    }
    var fe: FE = func FE {
        set x = _(x+1)
    }
    var ft: FT = func FT {
        set x = _(x+1)
    }
    {
        set finp = _{stropen("r", 0, "pass ; pass")}
        call lexer
        {
            var s: Stmt = call parser_stmts
            call visit_stmt [borrow \\s, [<.2 fs>,<.1>,<.1>]]
        }
        call _assert _(x == 3)
        call _fclose finp
    }
    set x = _0
    {
        set finp = _{stropen("r", 0, "var x: () = ()")}
        call lexer
        {
            var s: Stmt = call parser_stmts
            call visit_stmt [borrow \\s, [<.2 fs>,<.2 fe>,<.2 ft>]]
        }
        call _assert _(x == 4)
        call _fclose finp
    }
}

call t_pre
call t_lexer
call t_parser
call t_visit

output std ()
