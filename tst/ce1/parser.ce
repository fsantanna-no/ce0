-- EOF,sym,key,var,unit
var@ parser_type: ()->Maybe(Type) = func ()->Maybe(Type) {
    if tk_accept [_5,<.1>] {
        return <.2 new <.1>>        -- Unit
    }
    var ok: _int = call tk_accept [_2, <.2 _('[')>]
    if _(!ok) {
        set ok = call tk_accept [_2, <.2 _('<')>]
    }
    if ok {
        var open: _int = tk0!2
        var tp: Maybe(Type) = call parser_type ()
        var tps: List(Type) = new <.1 [consume tp!2, <.0>]>
        loop {
            set ok = tk_accept [_2, <.2 _(',')>]
            if _(!ok) {
                break
            }
            set tp = call parser_type ()
            set tps = new <.1 [consume tp!2, consume tps]>
        }
        if _(open == '[') {
            call _assert tk_accept [_2, <.2 _(']')>]
            return <.2 new <.2 consume tps>>
        } else {
            call _assert tk_accept [_2, <.2 _('>')>]
            return <.2 new <.3 consume tps>>
        }
    }

    return <.1>
}

var@ parser_stmts: ()->Stmt = ?

-- EOF,sym,key,var,unit
-- Unit, Var, TCons, UCons, TDisc, UDisc, Call, Func
var@ parser_expr: ()->Maybe(Expr) = func ()->Maybe(Expr) {
    if tk_accept [_5,<.1>] {    -- Unit
        return <.2 new <.1>>
    }
    if tk_accept [_4,<.1>] {    -- Var
        return <.2 new <.2 copy tk0!4>>
    }
    if tk_accept [_2, <.2 _('[')>] {
        var e: Maybe(Expr) = call parser_expr ()
        var es: List(Expr) = new <.1 [consume e!2, <.0>]>
        loop {
            if tk_accept [_2, <.2 _(',')>] {
                set e = call parser_expr ()
                set es = new <.1 [consume e!2, consume es]>
            } else {
                break
            }
        }
        call _assert tk_accept [_2, <.2 _(']')>]
        return <.2 new <.3 consume es>>
    }
    if tk_accept [_2, <.2 _('<')>] {
        call _assert tk_accept [_2, <.2 _('.')>]
        call _assert tk_accept [_6, <.1>]
        var n: _int = tk0!6
        var e: Maybe(Expr) = call parser_expr ()
        if e?2 {
            -- ok
        } else {
            set e = <.2 new <.1>>
        }
        call _assert tk_accept [_2, <.2 _('>')>]
        return <.2 new <.4 [n, consume e!2]>>
    }
    var ok: _int = call tk_accept [_3, <.1>]
    if _(ok) {
        if tk0!3?4 {  -- func
            var tp: Maybe(Type) = call parser_type ()
            call _assert tp?2
            call _assert tk_accept [_2, <.2 _('{')>]
            var s: Stmt = call parser_stmts ()
            call _assert tk_accept [_2, <.2 _('}')>]
            return <.2 new <.9 [consume tp!2, consume s]>>
        }
    }
    return <.1>
}

var@ parser_exprs: ()->Maybe(Expr) = func ()->Maybe(Expr) {
    var e1: Maybe(Expr) = call parser_expr
    if e1?1 {
        return <.1>
    }

    loop {
        var ok: _int = call tk_accept [_2, <.2 _('.')>]
        if _(!ok) {
            set ok = call tk_accept [_2, <.2 _('!')>]
            if _(!ok) {
                set ok = call tk_accept [_2, <.2 _('?')>]
            }
        }
        if _(!ok) {
            break
        }
        var chr: _int = tk0!2

        call _assert tk_accept [_6, <.1>]
        var n: _int = tk0!6

        if _(chr=='.') {
            set e1 = <.2 new <.5 [consume e1!2, n]>>
        }
        if _(chr=='!') {
            set e1 = <.2 new <.6 [consume e1!2, n]>>
        }
        if _(chr=='?') {
            set e1 = <.2 new <.7 [consume e1!2, n]>>
        }
    }

    var n1: _int = call _ftell finp
    var e2: Maybe(Expr) = call parser_expr
    if e2?1 {
        var n2: _int = call _ftell finp
        call _assert _(n1 == n2)
        return <.2 consume e1!2>
    } else {
        return <.2 new <.8 [consume e1!2, consume e2!2]>>
    }
}

var@ parser_stmt: ()->Maybe(Stmt) = func ()->Maybe(Stmt) {
    var ok: _int = call tk_accept [_3, <.1>]
    if _(!ok) {
        return <.1>
    }
    if tk0!3?1 {  -- pass
        return <.2 new <.1>>
    }
    if tk0!3?3 {  -- var x: TP = ...
        call _assert tk_accept [_4, <.1>]
        var id: String = copy tk0!4
        call _assert tk_accept [_2, <.2 _(':')>]
        var tp: Maybe(Type) = call parser_type
        call _assert tk_accept [_2, <.2 _('=')>]
        var e: Maybe(Expr) = call parser_expr
        return <.2 new <.2 [consume id, consume tp!2, consume e!2]>>
    }
    call _assert _0
}

set parser_stmts = func ()->Stmt {
    var ret: List(Stmt) = <.0>
    loop {
        call tk_accept [_2, <.2 _(';')>]
        var n1: _int = call _ftell finp
        var s: Maybe(Stmt) = call parser_stmt
        if s?1 {
            var n2: _int = call _ftell finp
            call _assert _(n1 == n2)
            break
        }
        set ret = new <.1 [consume s!2, consume ret]>
    }
    return new <.3 consume ret>
}
