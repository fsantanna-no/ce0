var@ string_len: \\String->_int = func \\String->_int {
    if (/arg)?0 {
        return _0
    } else {
        var n: _int = call string_len borrow \\(/arg)!1.2
        return _(1 + n)
    }
}

var@ string_ce2c: \\String->_(char*) = func \\String->_(char*) {
    native _{static char STRING[256];}
    var n: _int = string_len borrow arg
    var@ aux: [_int,\\String]->() = func [_int,\\String]->() {
        var i: _int = arg.1
        if (/arg.2)?1 {
            var c: _int = (/arg.2)!1.1
            native _{STRING[n-i] = c;}
            return aux [_(i+1), borrow \\(/arg.2)!1.2]
        }
    }
    call aux [_1, borrow arg]
    native _{STRING[n] = '\\0';}
    return _STRING
}

var@ string_c2ce: _(char*)->String = func _(char*)->String {
    var ret: String = <.0>
    var n: _int = call _strlen arg
    var i: _int = _0
    loop {
        if _(i == n) {
            break
        }
        set ret = new <.1 [_(arg[i]), consume ret]>
        set i = _(i + 1)
    }
    return consume ret
}

var@ string_eq: [\\String,\\String]->_int = func [\\String,\\String]->_int {
    var nil1: _int = (/arg.1)?0
    var nil2: _int = (/arg.2)?0
    if nil1 {
        return nil2
    }
    if nil2 {
        return nil1
    }
    var c1: _int = (/arg.1)!1.1
    var c2: _int = (/arg.2)!1.1
    if _(c1 == c2) {
        return string_eq [borrow \\(/arg.1)!1.2, borrow \\(/arg.2)!1.2]
    }
    return _0
}
